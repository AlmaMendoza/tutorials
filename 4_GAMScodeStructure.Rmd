---
title: "Look at the GAMS code and its structure"
subtitle: MAgPIE model development team (magpie@pik-potsdam.de)
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: Kristine Karstens (karstens@pik-potsdam.de), Felicitas Beier (beier@pik-potsdam.de)
output:
  rmarkdown::github_document:
    toc: yes
---

# 1. Introduction

The inner core of the MAgPIE model is written in GAMS. For the execution of the code, all parts of the code have to be put into a single file, the `full.gms`. All code chunks are stored within the `modules` folder. Every module, representing a component of the model, has several realizations, which are found in the `modules` folder. 
For the final model execution, exactly one realization of each module is chosen and included.  The configuration settings that are set in `default.cfg` (or inside the run scripts) determine the realization entering the `full.gms`. 

### Learning objectives

The goal of this exercise is to understand the basic structure of the GAMS code. After completion of this exercise, you will be able to:

1. Navigate though the GAMS code.
2. Understand the basic structure of modules and realizations.
3. Understand the basic rules of variable or parameter naming conventions and their meanings.

# 2.1. Structure of a module

When you open the `modules` folder, you will see a long list of all modules and the `module.gms` (including an overall module description and ensuring the inclusion of the respective module realizations in the `full.gms`). Every module folder is built following the same structure:

```{r, echo=FALSE, fig.cap="structure of any module", out.width = '100%',fig.align='center'}
knitr::include_graphics("figures/module_struc.png")
```

The module structure contains

* a module description and listing of all realizations in the module.gams-file 
* the source code of each realization in the respective realization folders 
* overarching input files for all realizations of the module in the input folder.

New realizations can be added by keeping that structure (more in `7_advanced_changeCode.Rmd`). In that sense MAgPIE is easily extentable.

# 2.2. Structure within each realization

Within a realization the source code is distributed over several gms-files. This is nessessary to ensure the correct order of calculations (before, within and after the optimization). Moreover, the correct interfaces for model inputs and outputs are defined by this structure. In the following table, you see the purpose of each gms-file. Note that not every gms-files is needed in every realization. 


| gms.file   | function                |
|:------------------|:------------------------------------------------------------------|
| declarations.gms  | Declares all variables, equations, parameters that are central to this realization. |
| equations.gms     | Contains functional relationships that have to be fullfilled within the optimization. |
| input.gms         | Loads input from `any_module/input` or `any_module/a_realization/input` |
| sets.gms          | Lists sets that are used (mainly) within this specific realization or are needed for interfaces defined within this realilzation |
| realization.gms   | Includes a description of the respective realization and lists the files to be included. |
| preloop.gms       | Includes calculations to be executed before the model run. |
| presolve.gms      | Includes calculations to be executed before each time step.|
| postsolve.gms     | Includes calculations to be executed after each time step and defines output.|
| nl_fix.gms        | Fixes non-linear behaviour to linear behavior.|
| nl_release.gms    | Releases restrictions to linear behavior again. |
| not_used.txt      | Lists interfaces (declared in other modules) that are not used within this realization, but in other realizations of the same module | 


# 2.3 Coding etiquette variable and parameter naming

The MAgPIE model structure is build upon the idea that every module itself is encapsulated just interacting on a **clearly defined interface** with other modules. This reflects the idea that every module represents a seperated part of the model, that could be representated in a simple or more sophisticated manner, without relying on other modules. In this sense realizations are replaceable within a module, since all realizations of a module have to deliver/interact with the same interface variables. The is ensured by defined rules for variable and parameter naming.

### Coding Etiquette

The following prefixes are used within the model code:

    q_ eQuations
    v_ Variables
    s_ Scalars
    f_ File parameters - these parameters contain data read from input file
    i_ Input parameters - influence the optimzation, but are not influenced by it
    p_ Processing parameters - influence optimization and are being influenced by it
    o_ Output parameters - influenced by optimization, but without effect on the optimization
    x_ eXtremely important output parameters - output parameters, that are necessary for the model to run properly (required by external postprocessing). They must not be removed.
    c_ switches from the Config.gms - parameters, that are switches to choose different scenarios
    m_ Macros

The prefixes have to be extended in some cases by a second letter:

    ?m_ module-relevant object - This object is used by at least one module and the core code. (Changes related to this object have to be performed carefully).
    ?00_ (a 2-digit number) module-only object - This 2-digit number defines the module the object belongs to. This object is only used by the respective module. (It makes sure that different modules do not contain the same object).

Note that sets are treated slightly differently: Instead of adding a prefix sets have a 2-digit number suffix (defining the number of the module in which the set is exclusively used). If the set is used in more than one module, it does not have any suffix.

In other cases, the prefixes have to be extended by a second letter:

    ?c_ value for the Current timestep - necessary for constraints. Each *c_-object must have a time-dependent counterpart
    ?q_ parameter containing the values of an equation
    ?v_ parameter containing the values of a variable

Suffixes indicate the level of aggregation of an object:

    (no suffix) highest disaggregation available
    _(setname) aggregation over set
    _reg regional aggregation (exception)
    _glo global aggregation (exception)


